
 <!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  
    <title>每日一题 | Xinghunm</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Xinghunm">
    

    
    <meta name="description" content="前端题集">
<meta name="keywords" content="subject">
<meta property="og:type" content="article">
<meta property="og:title" content="每日一题">
<meta property="og:url" content="http://yoursite.com/2017/01/04/1.每日一题/index.html">
<meta property="og:site_name" content="Xinghunm">
<meta property="og:description" content="前端题集">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yoursite.com/images/1-29-1-sticky.gif">
<meta property="og:image" content="http://yoursite.com/images/1-29-2-sticky.gif">
<meta property="og:image" content="http://yoursite.com/images/mark_sweep.gif">
<meta property="og:updated_time" content="2019-03-18T10:49:37.766Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="每日一题">
<meta name="twitter:description" content="前端题集">
<meta name="twitter:image" content="http://yoursite.com/images/1-29-1-sticky.gif">

    
    <link rel="alternative" href="/atom.xml" title="Xinghunm" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.png">
    
    
    <link rel="stylesheet" href="/css/style.css">
</head>
</html>
  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Xinghunm">Xinghunm</a></h1>
				<h2 class="blog-motto">Change the world or change yourself</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">首页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search">
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</ul></nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope="" itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/01/04/1.每日一题/" title="每日一题" itemprop="url">每日一题</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Xinghunm" target="_blank" itemprop="author">Xinghunm</a>
		
  </p><p class="article-time">
    <time datetime="2017-01-04T13:36:05.000Z" itemprop="datePublished"> Published 2017-01-04</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">Contents</strong>
		
			
		
		</div>
		
		<p><strong>1、</strong> <code>&lt;img&gt;</code>的title和alt有什么区别</p>
<ul>
<li>title是鼠标移动到元素显示的值</li>
<li>alt是<code>&lt;img&gt;</code>特有的属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提高图片的可访问性，除了纯装饰图片都应设置有意义的值，搜索引擎会重点分析。</li>
</ul>
<p><strong>2、</strong> 从浏览器地址栏输入url到显示页面的步骤</p>
<ul>
<li>浏览器根据请求的url，交给DNS解析域名找到真实的Ip，向服务器请求数据。</li>
<li>服务器处理完成返回数据，浏览器接收数据(Html、js、css、image等)</li>
<li>浏览器对请求回的资源进行语法分析，建立相应的内部数据结构(Dom等)</li>
<li>载入解析到的资源文件，渲染页面、完成。</li>
</ul>
<p><strong>3、</strong>js遍历li的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;1&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;2&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p>
<p>=&gt;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const u = document.querySelector(&apos;ul&apos;);</span><br><span class="line">const lis = u.children;</span><br><span class="line">for(let i = 0; i &lt; lis.length; i++) &#123;</span><br><span class="line">  const li = lis[i];</span><br><span class="line">  console.log(li.innerText);</span><br><span class="line">&#125;</span><br><span class="line">或</span><br><span class="line">const realArr = [].slice.call(lis);</span><br><span class="line">realArr.forEach((li) =&gt; &#123;</span><br><span class="line">  console.log(li.innerText)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p><strong>4、</strong> JavaScript<code>===</code>和<code>==</code>的区别<br><code>===</code>即严格相等，它会比较等式两边值的类型和值是否相等，不会进行隐式转换<br><code>==</code>即宽松相等，进行比较前会将等式两边值转换为同一类型(两边都可能被转换)，再进行值的比较，如相等则相等。<br>需要指出的是NaN不等于任何值包括它自己(如正无穷不应该等于负无穷)，+0等于(<code>==</code>或<code>===</code>)-0(对于0而言没有正负之分)。<br>对于引用类型的变量，<code>==</code>和<code>===</code>都只会判断引用地址是否相等，而不会判断对象具体里的属性以及值是否相等。判断两个对象是否相等，一个简单的方法就是将他们转换为字符串再进行比较。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj1Str = Json.stringify(obj1);</span><br><span class="line">var obj2Str = Json.stringify(obj2);</span><br><span class="line">console.log(obj1Str === obj2Str);</span><br></pre></td></tr></table></figure></p>
<p><strong>5、</strong> JavaScript中null和undefined的区别<br>由于历史原因JavaScript中有null和undefined两个表示无的值，其区别很小，主要在于：</p>
<ul>
<li>null的类型为Object，undefined的类型为undefined</li>
<li>Number(null)为0，Number(undefined)为NaN</li>
<li>null表示没有对象，此处不该有值，undefined表示此处应该有值暂时缺少这个值</li>
</ul>
<p><strong>6、</strong> 常见http code及其含义</p>
<ul>
<li>信息响应(1xx)<br>表示服务器收到请求，需要请求者继续执行操作<ul>
<li>100 Continue: 客户端应继续其请求。</li>
</ul>
</li>
<li>成功(2xx)<br>表示服务器成功接收请求并处理返回<ul>
<li>200 Ok: 请求正常处理完毕。一般用于GET与POST请求</li>
<li>202 Accepted: 服务器已经接受到消息，但尚未处理</li>
<li>204 No Content: 服务器成功处理了请求但未返回任何内容</li>
<li>206 Partial Content: 服务器成功处理了部分get请求</li>
</ul>
</li>
<li>重定向(3xx)<br>表示需要客户端进一步操作才能完成请求<ul>
<li>301 Moved Permanently: 永久重定向，请求的资源已永久移动到新URI</li>
<li>302 Found: 临时重定向，资源临时移动到新的位置</li>
<li>304 Not Modified: 表示资源在由请求头中的If-Modified-Since或If-None-Match参数指定的这一版本之后没有被修改，客户端仍能够拿到该资源的缓存无需再次传送。</li>
<li>307 Temporary Redirect: 临时重定向，不允许更改请求方法</li>
</ul>
</li>
<li>客户端错误(4xx)<br>表示客户端可能发生了错误<ul>
<li>400 Bad Request: 由于明显的客户端错误(格式错误，太大的大小等)，服务器无法理解</li>
<li>401 Unauthorized: 要求身份验证</li>
<li>403 Forbidden: 服务器理解请求但拒绝执行</li>
<li>404 Not Found: 服务器没有找到资源</li>
</ul>
</li>
<li>服务器错误(5xx)<br>表示服务器无法完成请求<ul>
<li>500 Internal Server Error: 服务器遇到未知问题，无法处理请求</li>
<li>503 Service Unavailable: 由于过载或临时的服务器维护导致的服务器暂时无法处理请求</li>
</ul>
</li>
</ul>
<p><strong>7、</strong>  <strong>Coo</strong>kie, SessionStorage与LocalStorage区别</p>
<p><a href="https://github.com/fengyueran/web-cache-demo.git" target="_blank" rel="noopener">demo</a></p>
<ul>
<li>储存大小<ul>
<li>Cookie: 4kb左右</li>
<li>SessionStorage: 一般为5M</li>
<li>LocalStorage: 一般为5M</li>
</ul>
</li>
<li>生命周期<ul>
<li>Cookie: 默认是关闭浏览器后失效，可以设置失效时间</li>
<li>SessionStorage: 仅在当前会话有效，关闭tab页即失效</li>
<li>LocalStorage: 持久缓存除非主动清除(通过浏览器或JS)</li>
</ul>
</li>
<li>与服务器通信<ul>
<li>每次请求都会携带在http请求头中，可能带来性能问题</li>
<li>SessionStorage: 只在客户端起作用</li>
<li>LocalStorage: 只在客户端起作用</li>
</ul>
</li>
</ul>
<p><strong>8、</strong>  html代码中让链接在新窗口中打开的写法</p>
<p>通过设置a标签的target属性为_blank可以在新窗口打开链接，但是由于新页面与原页面在一个进程上，如果新页面开销极大则会对原页面性能造成影响。此外新页面还可通过window.openner访问原页面的窗口对象，并且可以通过window.opener.location = newURL将原页面导航至不同的网址。因此需要通过ref=”noopenner”来禁用window.opener。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;a href=&quot;http://www.xinghunm.com&quot;&gt;Welcome -  old window&lt;/a&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">      &lt;a href=&quot;http://www.xinghunm.com&quot; target=&quot;_blank&quot; ref=&quot;noopenner&quot;&gt;Welcome -  new window&lt;/a&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>9、</strong>  html5有哪些新特性，移除的元素有哪些？</p>
<p>html5现在已经不是标准通用标记语言SGML的子集了，主要是关于图像、位置、存储、多任务功能的增加。<br>新增:</p>
<ul>
<li>WebSocket</li>
<li>Webworker</li>
<li>SharedWorker</li>
<li>用于绘画的canvas元素</li>
<li>用于媒介回放的vedio和audio元素</li>
<li>新增sessionStorage和localStorage对离线缓存更好的支持</li>
<li>新的特殊内容元素，如article、header、footer、nav、section</li>
<li>新的表单控件，如calendar、date、time、email、url、search<br>移除:</li>
<li>basefont</li>
<li>big</li>
<li>center</li>
<li>dir</li>
<li>font</li>
<li>frame</li>
<li>frameset</li>
<li>noframes</li>
<li>strike</li>
<li>tt</li>
</ul>
<p><strong>10、</strong>  谈谈对盒模型的理解</p>
<p>浏览器在对文档进行布局时，会根据盒模型(CSS Basic Box model)将所有元素表示成一个矩形盒子，矩形盒子的组成由内容区域、边框、内边距及外边距组成。如下盒模型分为W3C标准盒模型和IE盒模型，W3C标准盒模型的大小由内容区域(content)、边框(border)、内边距(padding)决定，而IE盒模型的大小只由内容区域的大小(自定义的width和height)决定。css可以通过box-sizing来切换两种盒模型。<br>矩形盒子</p>
<ul>
<li>W3C标准盒模型(box-sizing: content-box)<br>size = content + border + padding</li>
<li>IE盒模型(box-sizing: border-box)<br>size = content</li>
</ul>
<p>我们在编写html时若不声明DOCTYPE类型，IE浏览器会将盒子模型解释为IE盒模型，FireFox等会将其解释为W3C盒子模型，从而渲染出不同的结果。</p>
<p><strong>11、</strong>  主流的浏览器内核有哪些</p>
<ul>
<li>Trident<br>Trident为在早期的IE内核，没有使用W3C标准，国内多数浏览器(360、腾讯、搜狗等)都采用过该内核。</li>
<li>Gecko<br>Gecko(火狐内核)，代码开源，也是一个跨平台内核。</li>
<li>Presto<br>Presto(Opera前内核)，渲染速度快兼容性差，现已废弃而采用Google Chrome的Blink内核。</li>
<li>Webkit<br>Webkit(Safari内核)，主要由渲染引擎WebCore和javascript解释引擎JSCore组成，代码开源。</li>
<li>Chromium/Blink<br>2008年谷歌发布了chrome浏览器，其内核被命名为chromium，chromium代码fork自开源引擎webkit并对其进行重新梳理。<br>2013年谷歌决定从WebKit衍生出自己的Blink(WebKit的分支)引擎，后由Google和Opera Software共同研发。</li>
</ul>
<p><strong>12、</strong>  前端页面分层</p>
<ul>
<li>结构层<br>由HTML或XHTML创建，通过语义化的标签来描述页面的局部结构(不包含如何显示这些标签的内容)，从而构建出整个页面的结构。</li>
<li>表示层<br>由CSS创建，CSS对如何显示这些标签内容进行了回答。</li>
<li>行为层<br>行为层回答了内容应该如何对事件作出反应</li>
</ul>
<p><strong>13、</strong>  以下输出的内容</p>
<p>函数作用域内var声明是局部变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">function func()&#123;console.log(a);var a = &quot;in&quot;;&#125;</span><br><span class="line">func();</span><br><span class="line">=&gt; undefined</span><br></pre></td></tr></table></figure></p>
<p><strong>14、</strong>  以下输出的内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(</span><br><span class="line">  function func() &#123;</span><br><span class="line">    var a = b =&apos;res&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">)();</span><br><span class="line"></span><br><span class="line">//b前面没有跟着var相当于全局变量，所有输出res</span><br><span class="line">console.log(b);//res</span><br><span class="line">//a前面没有跟着var所以a是局部变量，所有输出undefined</span><br><span class="line">console.log(a);</span><br></pre></td></tr></table></figure>
<p><strong>15、</strong>  用js写一个继承实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function Parent(name, age) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">  function getName() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child(name, age) &#123;</span><br><span class="line">  Parent.call(this, name, age)</span><br><span class="line">  this.weight = 120;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const snow = new Child(&apos;snow&apos;, &apos;20&apos;);</span><br><span class="line">console.log(snow.name)</span><br></pre></td></tr></table></figure>
<p><strong>16、</strong>  匹配文档中的关键字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const colorKeyWords = (node, targetValue) =&gt; &#123;</span><br><span class="line">  const HIGHLIGHT_COLOR = &quot;orange&quot;;  </span><br><span class="line">  const highlightTag = &quot;&lt;span style=&apos;background-color: &quot;+HIGHLIGHT_COLOR+&quot;;&apos;&gt;&quot; + targetValue + &quot;&lt;/span&gt;&quot;;</span><br><span class="line">  let htmlStr = node.innerHTML;</span><br><span class="line"></span><br><span class="line">  const targetReg = new RegExp(targetValue, &quot;ig&quot;);</span><br><span class="line">  htmlStr = htmlStr.replace(targetReg, highlightTag);</span><br><span class="line">  node.innerHTML = htmlStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>17、</strong>  单击以下node时获取node的属性title和内容<code>&lt;div id=&quot;xhm&quot; title=&quot;blog&quot;&gt;my blog&lt;/div&gt;</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const node = document.getElementById(&quot;xhm&quot;);</span><br><span class="line">node.addEventListener(&apos;click&apos;, ()=&gt; &#123;</span><br><span class="line">  console.log(node.innerText); // my blog</span><br><span class="line">  console.log(node.getAttribute(&apos;title&apos;)); // blog</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>18、</strong>  link和@import的区别</p>
<ul>
<li><p>从属关系不同<br>link属于XHTML提供的标签，除了加载CSS外还可以做其他事情，比如定义RSS、定义rel连接属性等，而@import只能用于加载CSS。</p>
</li>
<li><p>加载时机不同<br>link引用CSS时，在页面加载的同时加载，而@import引用的CSS要在页面加载完后再加载。</p>
</li>
<li><p>兼容性不同<br>link属于XHTML标签，无兼容性问题。而@import是在CSS2.1提出的，低版本浏览器不支持。</p>
</li>
<li><p>DOM可控性的不同<br>link支持使用JavaScript控制DOM去改变样式，而@import不支持。</p>
</li>
</ul>
<p><strong>19、</strong> 修改chrome浏览器表单自动填充后的黄色背景</p>
<ul>
<li><p>取消chrome的自动填充</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input autoComplete=&quot;new-password&quot; /&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置内阴影来覆盖黄色背景</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&amp;: -webkit-autofill &#123;</span><br><span class="line">  -webkit-box-shadow: 0 0 0 1000px white inset;</span><br><span class="line">  -webkit-text-fill-color: black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置动画</p>
<p>通过动画设置其背景永远为透明。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&amp;:-webkit-autofill &#123;</span><br><span class="line">   animation: autofill-fix 1s infinite;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">@keyframes autofill-fix &#123;</span><br><span class="line">  from &#123;</span><br><span class="line">    background-color: transparent;</span><br><span class="line">  &#125;</span><br><span class="line">  to &#123;</span><br><span class="line">     background-color: transparent;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>20、</strong> JavaScript数据类型</p>
<ul>
<li>基本数据类型<ul>
<li>undefined</li>
<li>Null</li>
<li>Boolean</li>
<li>String</li>
<li>Number</li>
<li>Symbol(new in ES6)</li>
</ul>
</li>
<li>引用数据类型(Object类型)<ul>
<li>Object</li>
<li>Array</li>
<li>Date</li>
<li>RegRxp</li>
<li>Function</li>
</ul>
</li>
</ul>
<p><strong>21、</strong> js将一浮点数小数点左边的数字每三位加一个逗号</p>
<ul>
<li><p>利用parseInt的toLocaleString方法</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const formatNum = (num) =&gt; num.toString().replace(/(\d+)(.*)/g, </span><br><span class="line">match, s1, s2) =&gt; `$&#123;parseInt(s1).toLocaleString()&#125;$&#123;s2&#125;`)</span><br><span class="line"></span><br><span class="line">formatNum(15234555.55)</span><br><span class="line">=&gt; &quot;15,234,555.55&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>完全用正则替换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//当一个字符串中某个数字后跟着n对三个数字(\d&#123;3&#125;)就匹配这个数字</span><br><span class="line">const formateNum = (num) =&gt; &#123;</span><br><span class="line">  const numStr = num.toString();</span><br><span class="line">  //替换小数点左边的数字</span><br><span class="line">  return numStr.replace(/\d+/, (match) =&gt; &#123;</span><br><span class="line">    //替换目标数字为`$&#123;matchNum&#125;,`</span><br><span class="line">    return match.replace(/(\d)(?=(\d&#123;3&#125;+$))/, (s1) =&gt; `$&#123;s1&#125;,`);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">formateNum(435345.656)</span><br><span class="line">=&gt; &quot;435,345.656&quot;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>22、</strong> HTML常见的内联元素、块级元素以及空元素有哪些？</p>
<ul>
<li><p>内联元素</p>
<ul>
<li>a</li>
<li>img</li>
<li>input</li>
<li>label</li>
<li>span</li>
<li>br</li>
<li>select</li>
<li>strong</li>
<li>textarea</li>
</ul>
</li>
<li><p>块级元素</p>
<ul>
<li>div</li>
<li>h1-h6</li>
<li>form</li>
<li>hr</li>
<li>p</li>
<li>ul</li>
<li>table</li>
<li>option</li>
<li>li</li>
</ul>
</li>
<li><p>空元素</p>
<ul>
<li><code>&lt;br&gt;</code></li>
<li><code>&lt;hr&gt;</code></li>
<li><code>&lt;img&gt;</code></li>
<li><code>&lt;input&gt;</code></li>
<li><code>&lt;link&gt;</code></li>
<li><code>&lt;meta&gt;</code></li>
</ul>
</li>
</ul>
<p><strong>23、</strong> 移动开发中使用rem的优缺点</p>
<p>rem是CSS3新增的一个单位即root em，它与em的区别在于em是相对父元素的font-size，而rem相对的是HTML根元素。这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。因此对于移动开发而言，只要通过媒体查询来根据不同的屏幕宽度设置<code>&lt;html&gt;</code>元素的字体大小，就可以适配不同的屏幕。rem布局需要计算大小，相对麻烦，此外在引用第三方库时也适配也比较麻烦。</p>
<p><strong>24、</strong> js模块化分哪些阶段</p>
<ul>
<li><p>无模块化</p>
<p>js最初的作用只是进行表单验证或添加一些简单的动画，js文件通过<code>script</code>标签进行引用，没有模块化一说，随着前端复杂度提高想要引入更多的js文件就把多个<code>script</code>标签放在一起。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;script1.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;script2.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;script3.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>优点<br>相对于把所有逻辑放入一个文件，这种引入多个js文件实现简单模块化的思想是进步的。</li>
<li>缺点<br>污染全局作用域，文件间依赖关系不明显。</li>
</ul>
</li>
<li><p>CommonJS规范<br>CommonJS是一个JavaScript模块化规范，最初用于服务端的node。根据这个规范一个文件就是一个模块，其内部定义的变量函数只属于这个模块而不对外暴露。CommonJS通过exports或module.exports来导出需要对外提供的接口，通过require方法来同步加载所要依赖的模块。</p>
<ul>
<li><p>模块定义</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// util.js</span><br><span class="line">var x = 0;</span><br><span class="line">var add = function (value) &#123;</span><br><span class="line">  return value + x;</span><br><span class="line">&#125;;</span><br><span class="line">exports.x = x;</span><br><span class="line">module.exports.add = add;</span><br></pre></td></tr></table></figure>
</li>
<li><p>模块使用</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var util = require(./util.js); </span><br><span class="line">console.log(util.x); // 0</span><br><span class="line">console.log(util.add(1)); // 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>优点<br>解决了全局污染及模块间依赖的问题</p>
</li>
<li>缺点<br>CommonJS为同步加载，在服务端因其文件都在本地，同步加载没有问题，但在浏览器端文件需要异步加载 CommonJS就不再适用了。</li>
</ul>
</li>
<li><p>AMD规范<br>AMD(Asynchronous Module Definition)规范为异步加载模块，并允许指定回调函数，实现AMD规范的加载器JS主要有两个require.js 和 curl.js。<br>AMD标准中定义了两个API，define和require: </p>
<ul>
<li><p>模块定义: define(id, [depends], callback)</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//math.js，定义了一个math模块</span><br><span class="line">define(function () &#123;</span><br><span class="line">  var add = function (x, y) &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">  &#125;</span><br><span class="line">  return &#123;</span><br><span class="line">    add: add,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>模块使用: require([module], callback)</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">require([&apos;math&apos;], function (math)&#123;</span><br><span class="line">  console.log(math.add(1,1));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>优点<br>适合在浏览器环境中异步加载模块，并可以并行加载多个模块。</p>
</li>
<li>缺点<br>提高了开发成本，且不能按需加载，而是必须提前加载所有的依赖。</li>
</ul>
</li>
</ul>
<ul>
<li><p>CMD规范<br>CMD(Common Module Definition)规范是seajs推崇的规范，与requirejs类似，其不同点在于其加载模式为按需加载。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define(function(require, exports, module) &#123;</span><br><span class="line">  var a = require(&apos;pdf.js&apos;);</span><br><span class="line">  a.doSomething();</span><br><span class="line">  // 依赖就近书写，什么时候用到什么时候引入</span><br><span class="line">  var b = require(&apos;./b&apos;);</span><br><span class="line">  b.doSomething();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>优点<br>实现了异步加载模块，并可以按需加载。</li>
<li>缺点<br>依赖SPM打包，模块的加载逻辑偏重。</li>
</ul>
</li>
<li><p>ES6模块化<br>前面的模块化方法都是社区自己实现的，而ES6的模块化方案是真正的规范。在ES6中通过import关键字引入模块，export关键字导出模块，目前浏览器尚不支持ES6因此需要用babel将代码转换为广泛支持的require。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import Counter from &apos;../counter&apos;;</span><br><span class="line"></span><br><span class="line">class Home extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Counter /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Home;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>25、</strong> 不用第三个变量，直接交换两个变量的值</p>
<ul>
<li><p>方法1: 利用技巧</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a = 5;</span><br><span class="line">var b = 6;</span><br><span class="line">a = a + b;</span><br><span class="line">b = a - b;</span><br><span class="line">a = a - b;</span><br><span class="line">    </span><br><span class="line">console.log(a); // 6</span><br><span class="line">console.log(b); // 5</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法2: 利用位运算<br>位运算当且仅当只有一个表达式的某位上为1时，结果的该位才为1。否则结果的该位为0。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">  var a = 5; // 二进制101</span><br><span class="line">  var b = 6; // 二进制110</span><br><span class="line">  a = a^b;</span><br><span class="line">=&gt; </span><br><span class="line">  a = 101</span><br><span class="line">      110</span><br><span class="line">      ---</span><br><span class="line">      011</span><br><span class="line"></span><br><span class="line">  b = a^b;</span><br><span class="line"></span><br><span class="line">=&gt;</span><br><span class="line">  b = 011</span><br><span class="line">      110</span><br><span class="line">      ---</span><br><span class="line">      101</span><br><span class="line">  </span><br><span class="line">  a = a^b;</span><br><span class="line">=&gt;</span><br><span class="line">  a = 011</span><br><span class="line">      101</span><br><span class="line">      ---</span><br><span class="line">      110</span><br><span class="line"></span><br><span class="line">  console.log(a); // 6</span><br><span class="line">  console.log(b); // 5</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>26、</strong> CSS创建平移动画</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 30px;</span><br><span class="line">  position: absolute;</span><br><span class="line">  background: blue;</span><br><span class="line">  left: 0;</span><br><span class="line">  top: 0;</span><br><span class="line">  animation: move 3s ease infinite; </span><br><span class="line"></span><br><span class="line">  @keyframes move &#123;</span><br><span class="line">    50% &#123;</span><br><span class="line">      left: 100px;</span><br><span class="line">      top: 100px;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 或</span><br><span class="line">  @keyframes move &#123;</span><br><span class="line">    50% &#123;</span><br><span class="line">      transform: translate(100px, 100px);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>27、</strong> js选择select下的option</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;select&gt;</span><br><span class="line">  &lt;option value=&quot;option1&quot;&gt;1&lt;/option&gt;</span><br><span class="line">  &lt;option value=&quot;option2&quot;&gt;2&lt;/option&gt;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br><span class="line">const selectNode = document.querySelector(&apos;select&apos;);</span><br><span class="line">// 1.设置value的值等于option的value来选中option</span><br><span class="line">selectNode.value = option2;</span><br><span class="line"></span><br><span class="line">// 2.设置selectedIndex来选中option</span><br><span class="line">selectNode.selectedIndex = 1;</span><br></pre></td></tr></table></figure>
<p><strong>28、</strong> CSS实现超出部分内容显示<code>...</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  //需限制其宽度</span><br><span class="line">  max-width: 100px;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  text-overflow: ellipsis;</span><br><span class="line">  white-space: nowrap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>29、</strong> CSS postion定位有哪几种情况</p>
<ul>
<li><p>static<br>static定位是默认的定位方式，元素出现在正常的文档流中，会忽略left、top、right、bottom以及z-index。</p>
</li>
<li><p>absolute<br>absolute定位即绝对定位，相对于除static定位元素的第一个父类元素进行定位，元素的位置通过left、top、right以及bottom 属性进行设置。</p>
</li>
<li><p>fixed<br>fixed定位即固定定位，类似于绝对定位，但它是相对于浏览器窗口进行定位的，元素的位置通过left、top、right以及bottom属性进行设置。</p>
</li>
<li><p>relative<br>relative定位即相对定位，相对的参考位置为元素自身所在文档流的位置(不管这个元素是否脱离正常文档流)，通过left、top、right以及bottom属性进行设置。相对定位虽然脱离了文档流，但计算其他元素在文档流中的位置时仍会以该元素正常的文档流位置进行计算，就好像元素还在原来的位置。</p>
</li>
<li><p>sticky<br>sticky定位即粘性定位，可以简单地认为是相对定位和固定定位的混合，元素在跨越特定阈值(top、left、right、bottom所确定的值)前为相对定位，之后为固定定位。<br>粘性定位的效果如下:</p>
<center><img src="/images/1-29-1-sticky.gif" width="500"></center><br>上图中，导航栏设置为粘性定位:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">height: 50px;</span><br><span class="line">background: deepskyblue;</span><br><span class="line">position: sticky;</span><br><span class="line">top: 0;</span><br></pre></td></tr></table></figure><br><br>可以看到导航栏距离距离上边框为0(阈值)时就不再继续向上滚动，即导航栏在距上边框的距离大于0时可以认为此时的position为relative且top的最小值为0，当导航栏距上边框的达到0时，可以认为position的值为fixed且此时相对于父级元素的top为0。<br>利用sticky还能实现层次滚动:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  #root &#123;</span><br><span class="line">    overflow: auto;</span><br><span class="line">    max-height: 200px;</span><br><span class="line">    border: 1px solid;</span><br><span class="line">  &#125;</span><br><span class="line">  dt &#123;</span><br><span class="line">    position: sticky;</span><br><span class="line">    top: -1px;</span><br><span class="line">    padding: 2px 0 0 12px;</span><br><span class="line">    background: deepskyblue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dd &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 0 0 0 12px;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;root&quot;&gt;</span><br><span class="line">    &lt;dl&gt;</span><br><span class="line">      &lt;dt&gt;A&lt;/dt&gt;</span><br><span class="line">      &lt;dd&gt;A1&lt;/dd&gt;</span><br><span class="line">      &lt;dd&gt;A2&lt;/dd&gt;</span><br><span class="line">      &lt;dd&gt;A3&lt;/dd&gt;</span><br><span class="line">      &lt;dd&gt;A4&lt;/dd&gt;</span><br><span class="line">      &lt;dd&gt;A5&lt;/dd&gt;</span><br><span class="line">      &lt;dd&gt;A6&lt;/dd&gt;</span><br><span class="line">    &lt;/dl&gt;</span><br><span class="line">    &lt;dl&gt;</span><br><span class="line">      &lt;dt&gt;B&lt;/dt&gt;</span><br><span class="line">      &lt;dd&gt;B1&lt;/dd&gt;</span><br><span class="line">      &lt;dd&gt;B2&lt;/dd&gt;</span><br><span class="line">      &lt;dd&gt;B3&lt;/dd&gt;</span><br><span class="line">      &lt;dd&gt;B4&lt;/dd&gt;</span><br><span class="line">      &lt;dd&gt;B5&lt;/dd&gt;</span><br><span class="line">      &lt;dd&gt;B6&lt;/dd&gt;</span><br><span class="line">    &lt;/dl&gt;</span><br><span class="line">    &lt;dl&gt;</span><br><span class="line">      &lt;dt&gt;C&lt;/dt&gt;</span><br><span class="line">      &lt;dd&gt;C1&lt;/dd&gt;</span><br><span class="line">      &lt;dd&gt;C2&lt;/dd&gt;</span><br><span class="line">      &lt;dd&gt;C3&lt;/dd&gt;</span><br><span class="line">      &lt;dd&gt;C4&lt;/dd&gt;</span><br><span class="line">      &lt;dd&gt;C5&lt;/dd&gt;</span><br><span class="line">      &lt;dd&gt;C6&lt;/dd&gt;</span><br><span class="line">    &lt;/dl&gt;</span><br><span class="line">  &lt;/div&gt;</span><br></pre></td></tr></table></figure><br><br>效果如下:<br><center><img src="/images/1-29-2-sticky.gif" width="500"></center>
</li>
<li><p>initial<br>设置默认值，可作用于任何CSS样式(IE不支持该关键字)。</p>
</li>
<li>inherit<br>继承父类的postion值，不会继承其left、top、right及bottom值。</li>
<li>unset<br>initial和inherit的结合，当该属性是默认继承属性时等同于inherit；当该属性是非继承属性时等同于initial。</li>
</ul>
<p><strong>30、</strong> 内联元素和块级元素的区别</p>
<p><strong>内联元素</strong></p>
<ul>
<li>和相邻的内联元素在同一行</li>
<li>设置width和height无效</li>
<li>margin上下无效，padding上下虽然可以设置，但并不会挤压其他元素的空间，在其他元素看来好像没有设置一样</li>
</ul>
<p><strong>块级元素</strong></p>
<ul>
<li>块级元素总是各占一行，垂直排列</li>
<li>宽度(width)、高度(height)、内边距(padding)和外边距(margin)都可设置</li>
</ul>
<p>内联元素可以通过该变display属性进行转换，</p>
<ul>
<li><code>display:block</code>: 表现形式如块级元素</li>
<li><code>display:inline</code>: 表现形式如内联元素</li>
<li><code>display:inline-block</code>: 表现形式如内联元素和块级元素，具有block元素可以设置宽高的特性，同时又具有内联元素的不换行等特性</li>
</ul>
<p><strong>31、</strong> js判断一个变量是否是数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fuction isArray(obj) &#123;</span><br><span class="line">  Object.prototype.toString().call(obj) === &quot;[object Array]&quot;;</span><br><span class="line">&#125;</span><br><span class="line">现代浏览器</span><br><span class="line">Array.isArray(obj)</span><br></pre></td></tr></table></figure>
<p><strong>32、</strong> JavaScript由哪三部分构成</p>
<ul>
<li>核心(ECMAScript)<br>ECMAScript仅仅是一个描述，定义了脚本语言所有的属性、方法和对象，其他语言可以实现 ECMAScript 来作为功能的基准</li>
<li>文档对模型(DOM)<br>它是HTML和XML的应用程序接口，DOM将整个页面规划成由节点层级构成的文档，HTML或XML页面的每个部分都是一个节点的衍生物</li>
<li>浏览器对象模型(BOM)<br>它提供了一种特性，可以对浏览器窗口进行访问和操作，使用BOM开发者可以移动窗口、改变状态栏中的文本以及执行其他与页面内容不直接相关的动作。</li>
</ul>
<p><strong>33、</strong> sql的注入原理及防范方法</p>
<p>通常服务器端都会根据客户端的请求来动态构建sql执行语句，sql注入是通过将恶意的sql语句添加到应用的输入参数中，从而在sql服务器后台解析执行。<br>防范方法:</p>
<ul>
<li>sql语句预编译和绑定变量<br>sql执行命令必须先通过语法分析，生成执行计划，预编译后不管注入的参数是什么都不会再执行，而是当作字符串字面值进行处理。</li>
<li>严格检查参数<br>只执行规定格式的参数可以避免部分的sql注入</li>
<li>使用安全函数<br>安全函数将参数的特殊字符进行编码，这样sql引擎就不会将参数当成sql语句进行解析了。</li>
</ul>
<p><strong>34、</strong> JavaScript的垃圾回收机制</p>
<p>JavaScript有自动垃圾回收机制，当然这并不意味着你不需要关心内存管理。<br>内存的生命周期大致分为内存的分配、内存的使用以及不需要时内存的释放。因此只要追踪内存的生命周期就能自动的对内存进行分配回收了，但是这并不容易，尤其要确定某块内存是否真的不需要了。因此，垃圾回收只能有限制的解决一般问题，主要有两种方法，引用计数和标记清除算法。</p>
<ul>
<li><p>引用计数法<br>在内存管理环境中，如果一个对象(包括函数作用域、全局词法作用域等)有访问另一个对象的权限，叫做一个对象引用另一个对象。当对象被引用的次数为0时就被回收。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123; v: 1 &#125;; // 对象&#123; v: 1 &#125;被变量a引用一次，引用计数为1</span><br><span class="line">var b = a; // 同样，对象&#123; v: 1 &#125;被变量b引用一次，引用计数为2</span><br><span class="line">a = null; // 对象引用次数减1</span><br><span class="line">b = null;// 对象引用次数减1，此时引用计数为0，对象可以被释放</span><br></pre></td></tr></table></figure>
<p>引用计数有一个潜在的问题，就是无法解决循环引用的问题。<br>如下，a、b互相引用，引用计数一直为1，导致不能自动回收。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;</span><br><span class="line">  var a = &#123;&#125;;</span><br><span class="line">  var b = &#123;&#125;;</span><br><span class="line">  a.value = b;</span><br><span class="line">  b.value = a;</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br></pre></td></tr></table></figure>
</li>
<li><p>标记清除算法</p>
<p>这个算法假定有一个叫跟(root)的对象(js中为window， node js为global)，垃圾回收器定期从根开始，找所有从根开始引用的对象，然后找这些引用对象引用的对象…将这些对象标记为active，其他的不能被根引用或间接引用的将被标记为garbage，最终将这些垃圾清除。<br>循环引用将不再是问题，上例中函数f执行完后，全局window就无法访问到对象a和b了，因此对象a、b将会被回收。</p>
<center><img src="/images/mark_sweep.gif" alt="标记清除意图]"></center><br><center>标记清除意图 </center>

</li>
</ul>
<p><strong>35、</strong> JavaScript中var和let去区别</p>
<p>let为ES6新增的命令，用来声明变量，用法与var类似，其区别如下:</p>
<ul>
<li><p>有效范围<br>在ES6之前，JS函数只有函数作用域和全局作用域，没有块级作用域，所以<code>{}</code>不能限制var所声明的变量的访问范围，而let声明的变量只在let声明时的代码块内有效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  let a = 1;</span><br><span class="line">  var b = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a // ReferenceError: a is not defined.</span><br><span class="line">b // 2</span><br></pre></td></tr></table></figure>
</li>
<li><p>变量提升<br>let不存在变量提升，var存在变量提升</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(a); // undefined</span><br><span class="line">var a = 1;</span><br><span class="line"></span><br><span class="line">console.log(b); // Uncaught ReferenceError</span><br><span class="line">let b = 2;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重复声明<br>let不能重复声明，var可以重复声明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">var a = 2;</span><br><span class="line"></span><br><span class="line">let b = 1;</span><br><span class="line">let b = 2; //Identifier &apos;b&apos; has already been declared</span><br></pre></td></tr></table></figure>
</li>
<li><p>暂时性死区<br>let有暂时性死区约束，如下在全局声明了变量a，又在块级作用域用let声明了a，ES6明确规定，如果块级作用域内存在let或const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭区域。凡是在声明之前使用这些变量，就会报错，这在语法上称为暂时性死区。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">if (true) &#123;</span><br><span class="line">  a = 2;// ReferenceError</span><br><span class="line">  let a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>36、</strong> Doctype作用？标准模式与兼容模式各有什么区别?</p>
<ul>
<li>作用<br><code>&lt;!DOCTYPE&gt;</code>声明位于HTML文档的第一行，处于<code>&lt;html&gt;</code>标签之前。用于告诉浏览器以什么文档标准来解析这个文档，DOCTYPE不存在或格式错误会导致浏览器用兼容模式来解析文档。</li>
<li>区别<br>标准模式是以浏览器支持的最高标准来运行，兼容模式中页面以宽松的向后兼容的模式进行显示，以防止老式浏览器无法正常工作。</li>
</ul>
<p><strong>37、</strong>  HTML5为什么只需要写<code>&lt;!DOCTYPE HTML&gt;</code>？</p>
<p>HTML5不是基于标准通用标记语言SGML(Standard Generalized Markup Language)的，因此不需要对文档类型定义DTD(Document Type Definition)进行引用，但是需要Doctype来规范浏览器的行为(让浏览器按照他们应该的方式来运行)。HTML4.01是基于SGML的，因此需要对DTD进行引用，才能告知浏览器所使用的文档类型。</p>
<p><strong>38、</strong>  介绍一下你对浏览器内核的理解。</p>
<p>主要分为两部分，渲染引擎和JS引擎。</p>
<ul>
<li>渲染引擎<br>主要负责获取网页内容(HTML、XML、图像等)、整理信息(CSS等)以及计算网页的显示方式，然后输出至显示器或打印机。不同的浏览器内核对网页的解释不同，所渲染出的网页效果也就不一样。</li>
<li>JS引擎<br>解析和执行javascript来实现网页的动态效果。<br>最初渲染引擎和JS引擎并没有区分地很明确，后来JS引擎越来越独立，内核就倾向于指渲染引擎。</li>
</ul>
<p><strong>39、</strong>  简述一下你对HTML语义化的理解。</p>
<p>用正确的标签做正确的事情。</p>
<ul>
<li>html语义化使页面结构更加清晰，便于对浏览器搜索引擎解析。</li>
<li>在没有CSS的情况下也以一种文档格式显示。</li>
<li>搜索引擎的爬虫也依赖于HTML的标签来确定上下文和各个关键字的权重，利于SEO。</li>
<li>有利于阅读代码的人理解网站的分块。</li>
</ul>
<p><strong>40、</strong> iframe有哪些优缺点？<br>优点:</p>
<ul>
<li>用来实现长连接，在websocket不可用的时候作为一种替代。</li>
<li>跨域通信。</li>
<li>无刷新上传文件，在FormData不可用时作为替代方案。</li>
<li>创建一个全新的独立的宿主环境。</li>
</ul>
<p>缺点:</p>
<ul>
<li>搜索引擎的爬虫还不能很好的处理iframe的内容，不利于SEO。</li>
<li>iframe会阻塞页面的加载，onload事件不能及时触发(动态的给iframe添加src值可<br>解决) 。</li>
<li>iframe和主页面共享连接池，而浏览器对同域的连接有限制，所以会影响页面的并行<br>加载(动态的给iframe添加src值可解决)。</li>
<li>样式和脚本需要额外链入，增加服务器的http请求。</li>
<li>多数小型的移动设备无法完全显示框架。</li>
<li>浏览器的后退按钮无效。</li>
</ul>
<p><strong>41、</strong> label的作用是什么？是怎么用的？<br>label标签用来定义表单控制间的关系，当用户选择该标签时，浏览器会自动将焦点转移到和该标签相关联的表单控件上。<br>如下: 通过将label标签的属性for的值设置为input的id就可以将label和input关联起来，点击label时就可以选中radio类型的表单了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;label for=&quot;Name&quot;&gt;Number:&lt;/label&gt;  </span><br><span class="line">  &lt;input type=&quot;radio&quot; id=&quot;Name&quot;/&gt;  </span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>42、</strong> 如何实现浏览器内多个标签页之间的通信? (阿里)</p>
<ul>
<li>WebSocket</li>
<li>SharedWorker</li>
<li>localstorage、cookies等本地存储方式</li>
</ul>
<p><strong>43、</strong> webSocket如何兼容低浏览器？(阿里)</p>
<ul>
<li>Adobe Flash Socket</li>
<li>ActiveX HTMLFile(IE)</li>
<li>基于mutipart编码发送XHR</li>
<li>基于长轮询的XHR</li>
</ul>
<p><strong>44、</strong> 页面可见性Page Visibility API 可以有哪些用途？</p>
<p>在web页面的开发中，如何判断用户是不是还在与页面交互是一个重要的问题，比如页面最小化了或隐藏在其他标签页后面，这时我们就可以做关闭页面正在播放的音乐或其他什么事情。<br>Page Visibility API由三部分构造:</p>
<ul>
<li>document.hidden: 表示页面是否隐藏的布尔值</li>
<li>document.visibilityState: 有4个可能的状态值<ul>
<li>hidden: 页面在后台标签页或浏览器最小化，此时页面对用户不可见</li>
<li>visible: 页面在前台标签页，此时页面至少有部分是可见的</li>
<li>prerender: 页面正在进行预渲染处理，文档只能从这个状态开始，不可能由其它状态变为这个状态，此时<br>document.hidden为true，</li>
<li>unloaded: 页面从内存中卸载清除</li>
</ul>
</li>
<li>visibilitychange事件: document.visibilityState状态发生变化时触发</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.addEventListener(&apos;visibilitychange&apos;, () =&gt; &#123;</span><br><span class="line">  console.log(document.visibilityState);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>45、</strong> 网页验证码是干嘛的，是为了解决什么安全问题。</p>
<p>为了区分用户是机器还是人，验证码对于人而言很容易识别，对于计算机则难以识别，这可以防止恶意的破解密码、刷票、论坛灌水或者利用特定的程序暴力破解方式进行不断的登录尝试。</p>
<p><strong>46、</strong> title与h1的区别、b与strong的区别、i与em的区别？</p>
<ul>
<li><p>title vs h1<br>title是关于元素的额外信息，当鼠标移动元素上时显示一段提示文本，而h1表示层次明确的标题，对页面信息的抓取也有很大影响。</p>
</li>
<li><p>b vs strong<br>b表示粗体文本，并没有明确的语义，而strong表示强调，有语气加强的含义，使用阅读设备阅读时<code>&lt;strong&gt;</code>会重读。</p>
</li>
<li><p>i vs em<br>i表示斜体，em表示强调的内容。</p>
</li>
</ul>
<p>以上主要是自然样式标签和语义样式标签的差别，应该多用语义样式标签，但不能滥用。</p>
<ul>
<li><p>自然样式标签</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b, i, u, s, pre</span><br></pre></td></tr></table></figure>
</li>
<li><p>语义样式标签</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strong, em, ins, del, code</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>47、</strong> CSS选择符有哪些？哪些属性可以继承？哪些属性不可以继承？CSS3新增伪类有哪些？</p>
<p><strong>CSS选择符</strong></p>
<ul>
<li>id选中器(# id)</li>
<li>类选择器(. class)</li>
<li>标签选择器(div、p)</li>
<li>相邻元素选择器(E + F)</li>
<li>子元素选择器(E &gt; F)</li>
<li>后代元素选择器(E F)</li>
<li>属性选择器([attribute])</li>
<li>伪类选择器(E:)</li>
<li>通配符选择器(*)</li>
</ul>
<p><strong>可继承属性</strong></p>
<ul>
<li>color</li>
<li>text-align、text-indent、text-transform</li>
<li>font、font-family、font-size、font-style、font-weight</li>
<li>line-height</li>
<li>cursor</li>
<li>visibility</li>
<li>word-spacing<br>…</li>
</ul>
<p><strong>不可继承属性</strong></p>
<ul>
<li>display</li>
<li>margin</li>
<li>padding</li>
<li>border</li>
<li>position</li>
<li>z-index</li>
<li>height、min-height、max-height</li>
<li>width、min-width、max-width</li>
<li>left、top、right、bottom<br>…</li>
</ul>
<p><strong>新增伪类</strong></p>
<ul>
<li>:enabled</li>
<li>:disabled</li>
<li>:checked</li>
<li>:only-child</li>
<li>:nth-child(n)</li>
<li>:first-of-type</li>
<li>:last-of-type<br>…</li>
</ul>
<p><strong>48、</strong> display有哪些值？说明他们的作用。</p>
<ul>
<li>none: 元素不显示，并从文档流中移除</li>
<li>inline: 显示为行内元素类型，同行显示，宽高不能设置</li>
<li>block: 显示为块级元素类型，换行显示，可设置宽高，默认宽度为父元素宽度</li>
<li>inline-block: 显示为行内块级元素类型，同行显示，可以设置宽高</li>
<li>list-item: 像块级元素一样显示并添加列表标记</li>
<li>table: 像table一样显示</li>
<li>inherit: 从父元素继承display属性值</li>
</ul>
<p><strong>49、</strong> css多列等高(高度不固定)如何实现？<br><strong>padding补偿法</strong><br>如下: 父容器(container)的高度是由子元素div中高的那一列(叫做higher)决定的，而子元素的高度由内容、边框、内边距、外边距的高度共同决定的，当设置子元素的底内边距padding-bottom和底外边距为相等的正负值后，高度相抵为0，此时父容器的高度由higher的内容和边框决定，当higher的高度增加时父容器的高度也跟着增加，子元素中较矮的那列则会用padding-bottom来补偿这部分高度差(因为padding足够大)，再设置父容器overflow: hidden则可以正好截取higher的高度进行显示，表面看上去就是两列等高。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  .container &#123;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">  &#125;</span><br><span class="line">  .div1 &#123;</span><br><span class="line">    float: left;</span><br><span class="line">    width: 200px;</span><br><span class="line">    background: blue;</span><br><span class="line">    padding-bottom: 2000px;</span><br><span class="line">    margin-bottom: -2000px;</span><br><span class="line">  &#125;</span><br><span class="line">  .div2 &#123;</span><br><span class="line">    float: left;</span><br><span class="line">    width: 200px;</span><br><span class="line">    background: red;</span><br><span class="line">    padding-bottom: 2000px;</span><br><span class="line">    margin-bottom: -2000px;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">  &lt;div1 class=&quot;div1&quot;&gt;</span><br><span class="line">  Most of the discussion was on what needed to be done now as we transitioned from the security issues to the challenging economic issues.</span><br><span class="line">  &lt;/div1&gt;</span><br><span class="line">  &lt;div2 class=&quot;div2&quot;&gt;</span><br><span class="line">  Most of the discussion was on what needed to be done now as we transitioned from the security issues to the challenging economic issues. Most of the discussion was on what needed to be done now as we transitioned from the security issues to the challenging economic issues.</span><br><span class="line">  &lt;/div2&gt;</span><br><span class="line">&lt;/Box&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>50、</strong> li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</p>
<p>由于浏览器默认会把行内元素间的空白字符(空格、换行、tab)渲染为一个空格，因此li之间就产生了空白间隔。<br>解决方法是书写li时写为一行或设置font-size为0。</p>
<p><strong>51、</strong> 为什么要初始化CSS样式。</p>
<p>因为浏览器兼容问题，不同的浏览器对有些标签的默认值是不一致的，如果没有初始化可能导致浏览器渲染的结果差异，但是初始化样式对SEO有一定影响，力求影响最小的情况下初始化。</p>
<p><strong>52、</strong> CSS里的visibility属性有个collapse属性值是干嘛用的？在不同浏览器下以后什么区别？</p>
<p>对普通元素设置visibility: collapse后这个元素会完全隐藏，但会占据局部空间，与visibility: hidden的效果一样，相当于此元素透明，如果元素为table，collapse会让table会隐藏但不会占据局部空间。<br>不同浏览器不同版本的表现并不一致，不建议使用。</p>
<p><strong>53、</strong> 请解释一下为什么需要清除浮动，清除浮动的方式？</p>
<p>清除浮动是为了清除使用浮动元素带来的影响，浮动的元素高度会塌陷，而高度的塌陷使我们后面的布局不能正常显示。<br>清除浮动的方式:</p>
<ul>
<li><p>利用clear属性</p>
<p>如下，设置box的clear的属性为left或both即可消除兄弟元素浮动的影响，clear的本质是添加外边距。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  .float-left &#123;</span><br><span class="line">    float: left;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background: blue;</span><br><span class="line">  &#125;</span><br><span class="line">  .box &#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background: gray;</span><br><span class="line">    clear: both;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;div class=&quot;float-left&quot; /&gt;</span><br><span class="line">  &lt;div class=&quot;box&quot; /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加空块级元素<br>如下，在浮动元素后添加空块级元素div，并设置其clear属性为both或left即可以清除浮动。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  .clear &#123;</span><br><span class="line">    clear: both;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;div class=&quot;float-left&quot; /&gt;</span><br><span class="line">  &lt;div class=&quot;clear&quot;/&gt;</span><br><span class="line">  &lt;div class=&quot;box&quot; /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>伪元素::after和::before(作用于浮动元素的父类)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  .float-father &#123;</span><br><span class="line">    &amp;::after &#123;</span><br><span class="line">      content: &quot;&quot;;</span><br><span class="line">      display: block;</span><br><span class="line">      clear: both;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;div class=&quot;float-father&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;float-left&quot; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;box&quot; /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>overflow的方法(作用于浮动元素的父类)<br>设置浮动元素父类的overflow为auto或hidden即可清除浮动，该方法是利用BFC的特性达到的效果，这与前述几种方法通过设置clear属性的本质是不一样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  .float-father &#123;</span><br><span class="line">    overflow: auto;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;div class=&quot;float-father&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;float-left&quot; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;box&quot; /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>53、</strong> 浏览器是怎样解析CSS选择器的？</p>
<p>样式系统从关键选择器开始匹配，然后从右向左查找选择器的的祖先祖先元素，如果匹配，则继续左移查询父元素，不匹配则放弃查找，相比从左到右的正向查找效率大大提高。</p>
<p><strong>54、</strong> 在网页中的应该使用奇数还是偶数的字体，为什么呢？<br>使用偶数字体更好，主要原因如下:</p>
<ul>
<li>比例关系<br>相对来说偶数字号容易和web页面的其他部分构成比例关系，如使用14号为正文字号，使用14 <em> 0.5 = 7px作为margin，14 </em> 1.5 = 21px作为标题。</li>
<li>ie6中会把13px的字号渲染为14px</li>
<li>汉字更均衡<br>比如14号的汉字，会去掉1px的间距，字体的实际宽度就是13px，这样汉字的中竖线正好平分汉字，使汉字显得更加均衡。</li>
</ul>
<p><strong>55、</strong> 元素竖向的百分比设定是相对于容器的高度吗？</p>
<p>高度是相对于父容器高度，padding-top,padding-bottom,margin-top,margin-bottom是相对于父容器宽度。</p>
<p><strong>56、</strong> 什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？</p>
<p>响应式设计就是根据设备环境(系统平台、屏幕尺寸)来进行相应的响应和调整。其主要原理就是通过媒体查询来适配不同环境下的UI，对于低版本IE来说不能使用媒体查询，则可以通过监听window resize事件添加新的类来实现PC端的响应式布局，此外还可以通过Respond.js来实现媒体查询。</p>
<p><strong>57、</strong> 如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）</p>
<p>多数显示器的默认频率是60Hz，即一秒钟刷新60次，因此理论上动画最小时间间隔是1 / 60 * 1000ms = 16.7ms。</p>
<p><strong>58、</strong> overflow: scroll时不能平滑滚动的问题怎么处理</p>
<p>开启硬件加速，-webkit-overflow-scrolling: touch  </p>
<p><strong>59、</strong> png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过webp？</p>
<ul>
<li><p>png(Portable Network Graphics)<br>直译就是便携式网络图片，简称PNG，是一种无损压缩的位图图形格式，支持索引、灰度、RGB三种颜色方案以及Alpha通道等特性。PNG的开发目标是改善并取代GIF作为适合网络传输的格式而不需要专利许可。<br>特性</p>
<ul>
<li>支持256色调色板技术以产生小体积文件</li>
<li>支持最高24位真彩色图像以及8位灰度图像</li>
<li>支持Alpha通道的透明/与半透明特性</li>
<li>支持无损压缩</li>
<li>支持存储附加信息，以保留图像名称、作者等信息</li>
<li>支持图像亮度的Gamma校准信息</li>
<li>渐进显示和流式读写，适合在网络传输中快速显示预览效果后再展示全貌<br>…</li>
</ul>
</li>
<li><p>jpg(Joint Photographic Experts Group)<br>jpg即jpeg，由于早期的DOS、Windows95只支持最长3字符的扩展名，为了兼容采用了.jpg，一直沿用到今天，JPEG是一种针对照片视频而广泛使用的有损压缩标准方法。支持24位真彩色，颜色丰富并且适合那些允许轻微失真的像素色彩丰富的图片(相片)不支持动画，不支持透明色，不适合logo和线条。</p>
</li>
<li><p>gif(Graphics Interchange Format)<br>是一种位图图形文件格式，它采用无损压缩技术，以8位色(即2556种颜色)重现真彩色的图像，它既可以减少文件的大小，又保持成像质量。GIF图片可以动并且拥有透明度(透明或不透明，并没有alpha通道)。适合logo、线条图。</p>
</li>
<li><p>webp<br>是一种同时提供了有损压缩和无损压缩(可逆压缩)的图片文件格式。它的优势在于拥有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，此外它还具备Alpha透明以及动画特性。</p>
</li>
</ul>
<p><strong>60、</strong> style标签写在body后与body前有什么区别？</p>
<p>写在body前有利于浏览器逐步渲染(resources download=&gt;CSSOM+DOM=&gt;RenderTree=&gt;Layout=&gt;Paint)，写在body标签后由于浏览器逐行方式对html文档进行解析，当解析到写在尾部的样式表时会导致浏览器停止之前的渲染，等待加载且解析样式表完成后重新渲染，在windows的IE下可能会出现FOUC现象(即样式失效导致的页面闪烁问题)。</p>
<p><strong>61、</strong> 什么是CSS 预处理器 / 后处理器？</p>
<ul>
<li><p>预处理器<br>CSS预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为CSS增加一些编程的特性，并将CSS作为目标生成文件。比如LESS、Sass、Stylus等用来预编译CSS，他们具有层级、mixin、变量、循环、函数等特性，极大的提高了UI开发效率。</p>
</li>
<li><p>后处理器<br>对CSS进行处理，属于广义上的CSS预处理器，我们很久以前就在用预处理器了，最典型的例子就是CSS压缩工具clean-css，目前最常用的后处理器就是PostCSS，用来在完成的样式表中根据CSS规范处理CSS，如给CSS属性添加浏览器私有前缀，实现各个浏览器的兼容。</p>
</li>
</ul>
<p><strong>62、</strong> 什么是Cookie隔离？</p>
<p>cookie隔离就是在http请求的时候不带cookie，如果静态文件都放在主域名下，那么在静态文件请求时都会把带有cookie的请求提交给server，非常浪费资源，所以不如隔离开。<br>因为cookie有域的限制，因此不能跨域请求，因此使用非主域名的时候，请求头中就不会带有cookie，这样就可以降低请求头的大小，降低请求时间，从而达到降低整体请求延时的目的。</p>
<p><strong>63、</strong> 什么是严格模式？</p>
<p>严格模式是ES5中添加的一种运行模式，这种模式使Javascript在更严格的条件下运行。不支持严格模式与支持严格模式的浏览器在执行严格模式代码时会采用不同的行为。</p>
<p>严格模式对正常的JS语义作了一些修改。</p>
<ul>
<li>严格模式通过抛出错误来消除一些原有的静默错误。</li>
<li>严格模式修复了一些导致JS引擎难以优化的缺陷：有时候，相同的代码，严格模式可以比非严格模式下运行得更快。</li>
<li>严格模式禁用了ECMAScript的未来版本可能定义的一些语法。<br>严格模式通过在语句前添加’use strict’来开启。</li>
</ul>
<p><strong>64、</strong> CSS3有哪些新特性？</p>
<ul>
<li>新增多种选择器</li>
<li>圆角(border-radius)</li>
<li>多列布局(multi-column layout)</li>
<li>文字特效(text-shadow)</li>
<li>线性渐变(gradient)</li>
<li>2D转换(translate、rotate、scale、skew)</li>
<li>过渡(transition)<br>…</li>
</ul>
<p><strong>65、</strong> [“1”, “2”, “3”].map(parseInt) 答案是多少？<br>parseInt函数解析一个字符串参数，并返回一个指定基数的十进制整数或NaN。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">  string: 要被解析的字值，如果不是字符串则转换为字符串，字符串开头的空白符将会被忽略</span><br><span class="line">  radix: 一个介于2-36的整数(或0)，表示一个参数string的基数。比如radix为2，表示第一个参数string为2进制数，当未指定基数或基</span><br><span class="line">         数为0时，会根据string来判断数字的基数(0x开头基数为16，0开头基数为8或10，具体由浏览器决定，其他的默认值为10，因此最好显示给定基数)。</span><br><span class="line">  返回值: 返回解析后的10进制整数值，解析错误则返回NaN。主要包含以下三种情况：</span><br><span class="line">         1. 被解析参数的第一个字符无法被转化成数值类型</span><br><span class="line">         2. 被解析的参数不是radix进制下的合法数字</span><br><span class="line">         3. radix不在[2, 36]范围内，或者不等于0</span><br><span class="line">*/</span><br><span class="line">parseInt(string, radix);</span><br></pre></td></tr></table></figure></p>
<p>[“1”, “2”, “3”].map(parseInt)等价于[“1”, “2”, “3”].map((v, index)=&gt; parseInt(v, index))，即<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">=&gt; parseInt(&quot;1&quot;, 0) //默认基数为10，因此返回1</span><br><span class="line">=&gt; parseInt(&quot;2&quot;, 1) //不在[2, 36]范围内，返回NaN</span><br><span class="line">=&gt; parseInt(&quot;3&quot;, 2) //基数为2，则任务&quot;3&quot;是2进制数，不合法，返回NaN</span><br></pre></td></tr></table></figure></p>
<p><strong>65、</strong> IE与火狐的事件机制有什么区别？ 如何阻止冒泡？<br>如下，inner和outer都绑定单击事件，当点击inner时，事件应如何传递呢，是inner先触发单击事件，还是outer先触发？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;outer&quot;&gt;</span><br><span class="line">  &lt;span id=&quot;inner&quot;&gt;</span><br><span class="line">    Click </span><br><span class="line">  &lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>事件冒泡和事件捕获</strong></p>
<ul>
<li>事件冒泡<br>IE的事件机制就是事件冒泡，事件冒泡，如同将石头丢入水底，泡泡会从水底，逐渐向上，直到水面，消失。也就是说事件会从最内层元素触发，并向上传播，直到document对象。<br>因此，IE事件机制处理上述的例子中span元素的单击事件顺序为: span=&gt;div&gt;body=&gt;html=&gt;document</li>
<li>事件捕获<br>事件捕获是网景提出来的事件流，它和事件冒泡正好相反，事件会从最外层元素开始触发，直到具体的元素。<br>因此，事件捕获机制处理上述的例子中span元素的单击事件顺序为: document=&gt;html=&gt;body=&gt;div=&gt;span<br>火狐支持事件冒泡和事件捕获。</li>
</ul>
<p><strong>addEventListener函数</strong><br>W3C折中了事件冒泡和事件捕获，制定了先捕获后冒泡的标准，addEventListener的第三个参数决定了事件是在捕获阶段还是在冒泡阶段触发。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">  event: 事件名</span><br><span class="line">  function: 触发事件时执行的函数</span><br><span class="line">  useCapture: 默认值为false，指定事件是在捕获阶段还是在冒泡阶段触发</span><br><span class="line">*/</span><br><span class="line">element.addEventListener(event, function, useCapture)</span><br></pre></td></tr></table></figure></p>
<p><strong>实例</strong></p>
<p>冒泡阶段触发:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//点击span，输出innner，再输出outer</span><br><span class="line">&lt;div id=&quot;outer&quot;&gt;</span><br><span class="line">  &lt;span id=&quot;inner&quot;&gt;</span><br><span class="line">    Click </span><br><span class="line">  &lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const outer = document.getElementById(&quot;outer&quot;);</span><br><span class="line">  outer.addEventListener(&quot;click&quot;, (e) =&gt; console.log(&quot;outer&quot;));</span><br><span class="line">  const innner = document.getElementById(&quot;innner&quot;);</span><br><span class="line">  innner.addEventListener(&quot;click&quot;, (e) =&gt; console.log(&quot;innner&quot;));</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>捕获阶段触发:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//点击span，输出outer，再输出innner</span><br><span class="line">&lt;div id=&quot;outer&quot;&gt;</span><br><span class="line">  &lt;span id=&quot;inner&quot;&gt;</span><br><span class="line">    Click </span><br><span class="line">  &lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const outer = document.getElementById(&quot;outer&quot;);</span><br><span class="line">  outer.addEventListener(&quot;click&quot;, (e) =&gt; console.log(&quot;outer&quot;), true);</span><br><span class="line">  const innner = document.getElementById(&quot;innner&quot;);</span><br><span class="line">  innner.addEventListener(&quot;click&quot;, (e) =&gt; console.log(&quot;innner&quot;)，true);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>如果元素同时绑定了捕获和冒泡阶段的事件，则先响应捕获阶段的事件，再响应冒泡阶段的事件。</p>
<p>阻止冒泡:<br>通过e.stopPropagation函数来阻止事件传播。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//点击span，只输出outer，</span><br><span class="line">&lt;div id=&quot;outer&quot;&gt;</span><br><span class="line">  &lt;span id=&quot;inner&quot;&gt;</span><br><span class="line">    Click </span><br><span class="line">  &lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const outer = document.getElementById(&quot;outer&quot;);</span><br><span class="line">  outer.addEventListener(&quot;click&quot;, (e) =&gt; &#123;</span><br><span class="line">    e.stopPropagation();</span><br><span class="line">    console.log(&quot;outer&quot;), true);</span><br><span class="line">  &#125;</span><br><span class="line">  const innner = document.getElementById(&quot;innner&quot;);</span><br><span class="line">  innner.addEventListener(&quot;click&quot;, (e) =&gt; console.log(&quot;innner&quot;)，true);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>66、</strong> Javascript中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？</p>
<p>hasOwnProperty，返回一个对象是否具有指定名称的属性。使用方法如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">  proName: 属性名</span><br><span class="line">  返回值: bool值</span><br><span class="line">*/</span><br><span class="line">object.hasOwnProperty(proName)</span><br></pre></td></tr></table></figure></p>
<p><strong>67、</strong> JSON的了解？<br>JSON(JavaScript Object Notation)是一种轻量级的数据交换格式，它是JavaScript的一个子集。数据格式简单，易于读写，占用宽带小。如{ “name”: “xinghunm”, “age”: 18 }。</p>
<p>JSON有两种表示结构对象和数组</p>
<ul>
<li><p>对象<br>对象以左大括号<code>{</code>开始，以右大括号<code>}</code>结束，括号间由key-value的键值对组成，键值对间由逗号’,’分割，最后一个键值对可以省略逗号，键值对的key为字符串，值可以是字符串、数值、对象、布尔值、数组以及null。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  &quot;name&quot;: &quot;xinghunm&quot;,</span><br><span class="line">  &quot;age&quot;: 18</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数组<br>数组以左中括号<code>[</code>开始，以右中括号<code>]</code>结束，中间由逗号分割的多个键值对列表组成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123; </span><br><span class="line">    &quot;name&quot;: &quot;xinghunm&quot;,</span><br><span class="line">    &quot;age&quot;: 18</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; </span><br><span class="line">    &quot;name&quot;: &quot;snow&quot;,</span><br><span class="line">    &quot;age&quot;: 18</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>JSON对象提供了字符串、对象相互转换的接口</p>
<ul>
<li><p>字符串转json对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const obj = JSON.parse(str)</span><br></pre></td></tr></table></figure>
</li>
<li><p>对象转JSON字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const jsonStr = JSON.Stringify(obj)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>68、</strong> js延迟加载的方式有哪些？</p>
<ul>
<li><p>defer<br>使脚本在页面加载完成后执行，在<code>&lt;script&gt;</code>元素中设置defer属性，相当于告诉浏览器立即下载脚本，但延迟执行。defer属性基本能保证脚本按着加载的顺序执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;bundle.js&quot; defer&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>async<br>使脚本在下载完成后立即执行，执行脚本会阻止html的解析。async属性使脚本以乱序执行为主。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;bundle.js&quot; defer&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>动态创建DOM</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;  </span><br><span class="line">  function loadJS() &#123;  </span><br><span class="line">    var element = document.createElement(&quot;script&quot;);  </span><br><span class="line">    element.src = &quot;bundle.js&quot;;  </span><br><span class="line">    document.body.appendChild(element);  </span><br><span class="line">  &#125;  </span><br><span class="line">  window.addEventListener(&quot;load&quot;,loadJS);  </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>69、</strong> requireJS 的核心原理是什么？</p>
<p>  requireJS是基于AMD模块加载规范，使用回调函数来解决模块加载的问题。</p>
<ul>
<li>核心原理<br>通过创建script标签，给标签设置src属性来实现模块加载的。</li>
<li>避免二次加载<br>模块定义了一个function，这个function实际是一个factory(工厂模式)，这个factory在需要(require(“xxx”))的时候才有可能被调用，如果检查到已经调用过，生成了模块实例，则直接返回实例而不再调用工厂方法。</li>
<li>缓存<ul>
<li>第一次加载模块时，会缓存该模块，以后再加载该模块，就直接从缓存中取出该模块的module.exports属性(不会再次执行该模块)。</li>
<li>如果需要多次执行模块中的代码，一般可以让模块暴露函数</li>
<li>模块的缓存可以通过require.cache拿到，同样也可以删除</li>
</ul>
</li>
</ul>
<p><strong>70、</strong> document.write和innerHTML的区别？</p>
<p>document.write是直接写入到页面的内容流，如果在写之前没有调用document.open，浏览器会自动调用open。每次写完毕之后重新调用该函数，会导致页面被重写。<br>innerHTML则是DOM页面元素的一个属性，代表该元素的html内容。可以对一个具体的元素进行修改，而不用刷新页面。</p>
<p><strong>71、</strong> DOM操作——怎样添加、移除、移动、复制、创建和查找节点?</p>
<ul>
<li><p>创建节点</p>
<ul>
<li><p>createDocumentFragment()<br>创建文档片段节点，文档片段不是实际的DOM结构，它是一个虚拟的dom节点，存在于内存中，所以对片段的更改不会影响文档，也就不会重新渲染文档。<br>DocumentFragment一个常见的用途是将dom子树封装在里面，并通过appendChild等方法将该片段插入的DOM中，这样片段中的节点就会移动到DOM中，而留下空白的DocumentFragment文档片段。因为所有的节点被一次性插入DOM中，只会触发一次渲染，提高了性能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var frag = document.createDocumentFragment();</span><br><span class="line">for(let i = 0;i &lt; 100;i++) &#123;</span><br><span class="line">  const el =document.createElement(&quot;div&quot;);</span><br><span class="line">  //操作片段的修改不会触发渲染</span><br><span class="line">  frag.appendChild(el);</span><br><span class="line">&#125;</span><br><span class="line">document.body.appendChild(frag);</span><br></pre></td></tr></table></figure>
</li>
<li><p>createElement(tagName)<br>创建标签名为tagName的节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var el = document.createElement(&quot;div&quot;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>createTextNode(text)<br>创建包含文本text的文本节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.createTextNode(&quot;text node&quot;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>createAttribute(name)<br>创建属性节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function setAttr() &#123;</span><br><span class="line">  var node = document.getElementById(&apos;root&apos;);</span><br><span class="line">  var attr = document.createAttribute(&quot;属性名&quot;);</span><br><span class="line">  attr.nodeValue = &quot;属性值&quot;;</span><br><span class="line">  node.setAttributeNode(attr);</span><br><span class="line">&#125;</span><br><span class="line">等同于</span><br><span class="line">function setAttr() &#123;</span><br><span class="line">  var node = document.getElementById(&apos;root&apos;);</span><br><span class="line">  node.setAttribute(&quot;属性名&quot;, &quot;属性值&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>操纵节点</p>
<ul>
<li><p>添加节点</p>
<ol>
<li><p>Node.appendChild(element)<br>该方法将一个节点添加到指定父节点的子节点列表末尾。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.body.appendChild(element);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Node.insertBefore(newNode, referenceNode)<br>该方法在参考节点之前插入一个拥有指定父节点的子节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">html:</span><br><span class="line">&lt;div id=&quot;root&quot;&gt;</span><br><span class="line">  &lt;div id=&quot;div1&quot;&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line"></span><br><span class="line">const newNode = document.createElement(&apos;div&apos;);</span><br><span class="line">const parentNode = document.getElementById(&apos;root&apos;);</span><br><span class="line">const referenceNode = document.getElementById(&apos;div1&apos;);</span><br><span class="line">parentNode.insertBefore(newNode, referenceNode);</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>删除节点<br>Node.removeChild(child)方法从DOM中删除一个子节点，并返回删除的节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const node = document.getElementById(&quot;app&quot;);</span><br><span class="line">if (node.parentNode) &#123;</span><br><span class="line">  node.parentNode.removeChild(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>替换节点<br>用指定的节点替换当前节点的一个子节点，并返回被替换掉的节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const replacedNode = parentNode.replaceChild(newChild, oldChild);</span><br></pre></td></tr></table></figure>
</li>
<li><p>复制节点<br>Node.cloneNode() 方法返回调用该方法的节点的一个副本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">  deep: 可选，是否采用深度克隆(如果为true该节点所有后代节点也会被克隆，如果为false只克隆该节点本身)</span><br><span class="line">*/</span><br><span class="line">const dupNode = node.cloneNode(deep);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>查找节点</p>
<ul>
<li><p>getElementById(id)<br>返回一个匹配特定 ID的元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">1. 如果当前文档中拥有特定ID的元素不存在则返回null.</span><br><span class="line">2. id是大小写敏感的字符串，代表了所要查找的元素的唯一ID.</span><br><span class="line">*/</span><br><span class="line">var element = document.getElementById(id);</span><br></pre></td></tr></table></figure>
</li>
<li><p>getElementsByTagName(tagName)<br>通过标签名查找，返回一个动态的包含所有指定标签名的元素的HTML集合HTMLCollection。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//搜索从element开始。请注意只有element的后代元素会被搜索，不包括元素自己。</span><br><span class="line">var elements = element.getElementsByTagName(tagName)</span><br></pre></td></tr></table></figure>
</li>
<li><p>getElementsByName()<br>根据给定的name返回一个在(X)HTML document的节点列表集合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//name是元素的name属性的值。</span><br><span class="line">var elements = document.getElementsByName(name)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p><strong>72、</strong> 移动端最小触控区域是多大?</p>
<p>苹果最初把44x44像素定为触控控件最小的尺寸，原因是在iphone3的分辨率下，44x44pixels对应人类食指指尖的平均大小–7x7毫米(拇指为9毫米)，但是随着分辨率的提高，44x44pixels已经达不到7毫米了，当然可以通过换算得到目标设备的最小触控像素。</p>
<p><strong>73、</strong> 移动端的点击事件的延迟，时间是多久，为什么会有？ 怎么解决这个延时？</p>
<p>点击延迟有300ms，这个延迟是由历史原因造成的，最初在iOS自带的浏览器safari上有双击缩放的功能，为了判断用户是否是双击事件<br>(点击到链接，如果立即响应则会错误跳转)而设置了Safari等待300ms。后来鉴于iPhone的成功，各家浏览器也实现了这个功能。<br>解决方案</p>
<ul>
<li>CSS touch-action<br>这个属性指定了相应元素上能够触发的用户代理，也就是浏览器的默认行为。如果将该属性值设置为none，则表示在该元素上的操作不会触发用户代理的任何默认行为，也就无需进行300ms的延迟判断。</li>
<li>FastClick<br>FastClick是一个是FT Labs专门为解决移动端浏览器300毫秒点击延迟问题所开发的一个轻量级的库。FastClick的实现原理是在检测到touchend事件的时通过DOM自定义事件立即触发一个模拟的click事件，并把浏览器在300ms之后的click事件阻止掉。</li>
</ul>
<p><strong>74、</strong> 什么是Polyfill？</p>
<p>Polyfill是英国Web开发者<a href="https://remysharp.com/" target="_blank" rel="noopener">Remy Sharp</a>想出来的名词，来源于英国的一个家装产品Polyfilla(刮墙的,在中国称为腻子)，可以磨平墙上的裂缝。Remy Sharp以此来表达用于实现一些浏览器不支持的原生API的代码。比如有些浏览器不支持Array.isArray函数，为了让这些浏览器可以支持这个api，我们就可以实现如下polyfill:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(!Array.isArray) &#123; </span><br><span class="line">  Array.isArray = function(obj) &#123; </span><br><span class="line">    return Object.prototype.toString().call(obj) === &quot;[object Array]&quot;;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/subject/">subject</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/subject/">subject</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://yoursite.com/2017/01/04/1.每日一题/" data-title="每日一题 | Xinghunm" data-tsina="" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev">
 <a href="/2017/02/01/16.JS中的原型/" title="JS中的原型">
  <strong>上一篇：</strong><br>
  <span>
  JS中的原型</span>
</a>
</div>


<div class="next">
<a href="/2016/10/10/11.css居中方法/" title="css居中方法">
 <strong>下一篇：</strong><br> 
 <span>css居中方法
</span>
</a>
</div>

</nav>

	

<section id="comments" class="comment">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>



</div>  
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/CSS/" title="CSS">CSS<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Git/" title="Git">Git<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/JS/" title="JS">JS<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/Other/" title="Other">Other<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/css/" title="css">css<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/html/" title="html">html<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/js/" title="js">js<sup>7</sup></a></li>
		  
		
		  
			<li><a href="/categories/network/" title="network">network<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/react/" title="react">react<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/server/" title="server">server<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/subject/" title="subject">subject<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/website/" title="website">website<sup>1</sup></a></li>
		  
		
		</ul>
</div>


  <div class="weixin">
  <br>
  <p class="asidetitle">微信</p>
  <p>我的微信号，和我一起成长：</p>
  <img src="/images/weixin.png" width="230px">
</div>


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer">
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Xinghunm <br>
			This is my blog, believe it or not.</p>
	</section>
	 
	<div class="social-font">
		
		
		
		
		
		
		
		
		
		
		<a href="mailto:316032603@qq.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2019 
		
		<a href="/about" target="_blank" title="Xinghunm">Xinghunm</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>




<script type="text/javascript">

var disqus_shortname = 'xinghunm';

(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
</script>










<!-- Analytics Begin -->

<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-28029597-1', '');  
ga('send', 'pageview');
</script>





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
